@startuml

class Manager {
- password: str
- datastore: Data
- mac_address_hash: str
- email: str
- userID: int
- passwords: List
- pending_passwords: List
- scanned_passwords: List
- client_permanent_key: bytes
- session_key: str
- server_public_key: str
+ __init__(email: str, password: str, datastore: Data, session_key: Optional[str] = None, server_public_key: Optional[str] = None)
+ save_initial_data(code: int, session_key: str, client_permanent_key: str)
+ clear_api_db()
- get_client_permanent_key(): str
- get_client_sharing_keys(): Tuple
- set_session_key()
- reset_client_sharing_keys()
+ validate_client_public_key()
+ get_all_passwords_full()
+ get_all_managers_users()
+ refresh()
+ create_random_password(length: int = 16): str
- set_server_key()
+ get_pending_shares(iterations: int = 0): List
+ accept_pending_share(passID: int, accept: bool)
+ check_no_pending(): bool
+ import_passwords(iterations: int = 0): str
+ get_passwords(): List
+ get_infos(): List
+ get_all(): List
+ export_all(iterations: int = 0): List
+ get_manager_info(passID: int): int
+ add_new_password(title: str, url: str, username: str, additional_info: str, password: str, iterations: int = 0): str
+ get_specific_password_info(passID: int, iterations: int = 0): List
+ get_password_additonal_info(passID: int, iterations: int = 0): List
+ delete_password(passID: int, iterations: int = 0): str
+ delete_password_instance(passID: int, new_manager_email: Optional[str] = None, iterations: int = 0): str
+ get_password_users(passID: int, manager: bool = False, iterations: int = 0): List
+ set_to_lockdown(passID: int, iterations: int = 0): str
- remove_from_lockdown(passID: int, iterations: int = 0): str
+ remove_password_user(passID: int, user_email: str, iterations: int = 0): str
+ remove_all_locked_down_passwords(online: bool = False): str
+ add_manager(passID: int, new_manager_email: str, iterations: int = 0): str
+ update_password(passID: int, new_info: str, type: str, iterations: int = 0): str
+ share_password_check(passID: int, new_manager_email: str, iterations: int = 0): List
+ share_password_confirm(passID: int, new_manager_email: str, manager: int, iterations: int = 0): str
+ scan_passwords(): List
+ validate_client_password(password: str): bool
+ reset_client_password(new_password: str, iterations: int = 0): str
}

class PyAnyWhereRequests {
_+ get_server_key(): str
_+ add_new_user(server_public_key: str, forename: str, names: str, client_email: str, password_hash: str, date_of_birth: str, phone_number: str, country: str, permanent_public_key: str, mac_address_hash: str): str
_+ confirm_new_user(server_public_key: str, client_email: str, mac_address_hash: str, code: str): str
_+ add_new_device_request(server_public_key: str, client_email: str, new_mac_address: str, password: str): str
_+ confirm_device_code(server_public_key: str, client_email: str, mac_address_hash: str, code: str): str
_+ authenticate_password(server_public_key: str, client_email: str, mac_address_hash: str, password: str): str
_+ confirm_new_device_password(server_public_key: str, client_email: str, mac_address_hash: str, password_confirmation: str): str
_+ reset_client_password(server_public_key: str, session_key: str, client_email: str, new_password_hash: str, raw_password: str, new_password_keys: str): str
_+ get_password_overview(server_public_key: str, session_key: str, client_email: str): str
_+ get_username(server_public_key: str, session_key: str, client_email: str, passID: int): str
_+ get_password(server_public_key: str, session_key: str, client_email: str, passID: int): str
_+ get_all_passwords(server_public_key: str, session_key: str, client_email: str): str
_+ set_to_lockdown(server_public_key: str, session_key: str, client_email: str, passID: int): str
_+ remove_lockdown(server_public_key: str, session_key: str, client_email: str, passID: int): str
_+ add_new_password(server_public_key: str, session_key: str, client_email: str, password: str, title: str, url: str, username: str, additional_info: str, password_key: str): str
_+ delete_password(server_public_key: str, session_key: str, client_email: str, passID: int): str
_+ add_manager(server_public_key: str, session_key: str, client_email: str, new_manager_email: str, passID: int): str
_+ get_password_users(server_public_key: str, session_key: str, client_email: str, passID: int, manager_only: bool = False): str
_+ delete_password_instance(server_public_key: str, session_key: str, client_email: str, passID: int, new_manager_email: str): str
_+ remove_password_user(server_public_key: str, session_key: str, client_email: str, passID: int, user_email: str): str
_+ update_password(server_public_key: str, session_key: str, client_email: str, passID: int, new_info: str, type: str): str
_+ get_pending_passwordkeys(server_public_key: str, session_key: str, client_email: str): str
_+ get_emails_sharing(server_public_key: str, session_key: str, requested_email: str): str
_+ share_password(server_public_key: str, session_key: str, client_email: str, passID: int, password_key: str, recipient_UserID: str, manager: bool, encrypted_sharing_symmetric_key: str): str
_+ insert_pending_keys(server_public_key: str, session_key: str, client_email: str, passID: int, password_key: str, accept: bool): str
_+ get_public_key(server_public_key: str, session_key: str, recipient_UserID: str): str
_+ reset_client_sharing_keys(server_public_key: str, session_key: str, new_key: str, client_email: str): str
_+ create_encryption_keys(server_public_key: str): Tuple[str, str, str, str]
_+ format_data(data_to_return: str, client_private_key: str): str
_+ send_request(request_header: str, data: dict = {}, client_public_key: list = [], encrypted_symmetric_key: str = ""): str
}

class Encrypt {
_+ encrypt_key_to_server(data: str, public_key: tuple): str
_+ encrypt_data_to_server(data: str, key: str): str
_+ encrypt_password_key_to_share(password_key: str, symmetric_key: str): str
_+ encrypt_symmetric_key_sharing(symmetric_key: str, e: int, n: int): str
_+ encrypt_password_key(password_key: str, client_permanent_key: str): str
_+ encrypt_password(password: str, password_key: str): str
}

class Decrypt {
_+ decrypt_key_from_server(data: str, private_key: tuple): str
_+ decrypt_data_from_server(data: str, key: str): str
_+ decrypt_password_key_to_share(password_key: str, symmetric_key: str): str
_+ decrypt_symmetric_key_sharing(symmetric_key: str, d: int, n: int): str
_+ decrypt_password_key(password_key: str, client_permanent_key: str): str
_+ decrypt_password(password: str, password_key: str): str
}

class Generate {
_+ generate_asymmetric_keys(): tuple
_+ generate_password_key(): str
_+ generate_symmetric_key(length: int = 24): str
_+ generate_fernet(extra: str = ""): Fernet
_+ validate_symmetric_key(encrypted_symmetric_key: str, max_length: int = 600000): bool
_+ create_error_check(length: int = 16): str
_+ validate_error_check(data: str): bool
}

class XorEncryption {
_+ encryptdecrypt(data: str, key: str): str
}

class Hash {
_+ create_hash(data: bytes, salt_type: str = "random"): str
_+ verify_hash(hash: str, data: bytes): bool
_+ create_client_permanent_key(client_raw_password: str, client_email: str): bytes
}

class PassInfo {
# passID: str
# title: str
# password_key: str
# password: str
# manager: int
# lockdown: int
# password_users: List
# password_managers: List
+ __init__(passID: str, title: str, manager: int)
+ get_summary(): str
+ get_passID(): str
+ get_manager(): int
+ get_password(client_email: Optional[str], session_key: Optional[str], server_public_key: Optional[str], client_permanent_key: Optional[str]): str
+ get_password_key(client_email: Optional[str], session_key: Optional[str], server_public_key: Optional[str]): Union[str, None]
# get_password_full(client_email: Optional[str], session_key: Optional[str], server_public_key: Optional[str], client_permanent_key: Optional[str])
+ delete_password(client_email: str, session_key: str, server_public_key: str): str
+ delete_password_instance(client_email: str, new_manager_email: str, session_key: str, server_public_key: str): str
+ set_to_lockdown(client_email: str, session_key: str, server_public_key: str): str
+ add_manager(client_email: str, new_manager_email: str, session_key: str, server_public_key: str): str
+ get_password_users(client_email: str, session_key: str, server_public_key: str): str
+ get_password_managers(client_email: str, session_key: str, server_public_key: str): str
+ update_password(client_email: str, session_key: str, server_public_key: str, new_info: str, type: str): str
+ share_password(client_email: str, session_key: str, server_public_key: str, recipient_userID: str, manager: int, client_permanent_key: str): str
+ remove_password_user(client_email: str, session_key: str, server_public_key: str, user_email: str): str
}

class Info {
+ __init__(passID: str, title: str, manager: int)
+ get_summary(): List
+ get_summary_inc_passID(): List
# get_password_full(client_email: Optional[str], session_key: Optional[str], server_public_key: Optional[str], client_permanent_key: Optional[str]): str
}

class Password {
- url: str
- username: str
- additional_info: str
+ __init__(passID: str, title: str, url: str, username: str, manager: int)
+ get_summary(): List
+ get_summary_inc_passID(): List
+ get_url(): str
+ get_username(): str
+ get_additional_info(): str
# get_password_full(client_email: Optional[str], session_key: Optional[str], server_public_key: Optional[str], client_permanent_key: Optional[str]): str
}

class Application {
_+ get_server_key(): str
_+ attempt_get_saved_data(): Union[Tuple[str, str], bool]
_+ save_login_data(email: str, password: str)
_+ delete_saved_login_data()
_+ login(email: str, password: str, datadic: dict): str
_+ get_user(): str
_+ login_new_device_request(email: str, password: str, datadic: dict): str
_+ login_new_device_confirm(email: str, code: str, datadic: dict): str
_+ create_new_account(forename: str, names: str, email: str, password: str, date_of_birth: str, phone_number: str, country: str, datadic: dict): str
_+ validate_new_account(email: str, code: str, datadic: dict): str
}

class PasswordChecker {
- passwords: list
+ __init__(passwords: list)
+ scan_all_passwords(): list
- __create_rating(password_dictionary: dict)
}

class PasswordGenerator {
_+ create_random_password(length: int): str
}

class AsyncRSA {
_+ generate_keys(random: bool = True, seed: str = "0"): Tuple[int, int]
_+ encrypt(x: int, e: int, n: int, encryptor: rsa.KeyGeneration): str
_+ encrypt_symmetric_key(key: str, e: int, n: int, increments: int = 4): str
_+ decrypt_symmetric_key(encrypted_key: str, d: int, n: int, increments: int = 4): str
}


class KeyGeneration {
+encrypt(m: unsigned long long int, e: unsigned long long int, n: unsigned long long int): unsigned long long int
+decrypt(c: unsigned long long int, d: unsigned long long int, n: unsigned long long int): unsigned long long int
+generateKeys(random: bool = true, s: string = ""): py::tuple
-gcd(a: unsigned long long int, b: unsigned long long int): unsigned long long int
-lcm(a: unsigned long long int, b: unsigned long long int): unsigned long long int
-isPrime(n: unsigned long long int): bool
-getpq(): pair<unsigned long long int, unsigned long long int>
-findpqFromString(s: const string&): pair<unsigned long long int, unsigned long long int>
-eulerTotient(p: unsigned long long int, q: unsigned long long int): unsigned long long int
-isCoprime(a: unsigned long long int, b: unsigned long long int): bool
-gete(totient: unsigned long long int): unsigned long long int
-modInverse(e: unsigned long long int, phi: unsigned long long int): unsigned long long int
-modPow(exponent: unsigned long long int, base: unsigned long long int, modulus: unsigned long long int): unsigned long long int
}


class PasswordAdder {
- homepage: Homepage
- current_state: string
- processing: bool
- add_password(e): void
- back(e): void
- insert_random_password(e): void
- switch(e): void
+ build(): void
}

class CodeSharer {
- code: str
- homepage: Homepage
- back(e)
- download_extension(e)
- copy_code(e)
+ build(): void
}

Deleter{
- homepage: Homepage
- data: Data
- passID: int
- type: str
- manager: int
- processing: bool
+ __init__(homepage: Homepage, data: Data, passID: int, type: str, manager: int)
- back(e): void
- delete_instance(e): void
- delete(e): void
+ build(): void

}

class Lockdown {
- homepage: Homepage
- passID: int
- type: str
- processing: bool
- init__(homepage: Homepage, passID: int, type: str): void
- set_to_lockdown(e): void
- back(e): void
+ build(): void
}


class NavSideRail {
- homepage: Homepage
- height: int
- nav: Container
+ __init__(homepage: Homepage): void
+ get_nav(): Container
+ get_selected_index(): int
+ set_selected_index(index: int): void
+ build(): void
}

class PasswordCard {
- homepage: Homepage
- data: Data
- title: str
- passID: int
- username: str
- url: str
- img: Image
+ __init__(homepage: Homepage, title: str, passID: int, username: str, url: str): void
+ get_title(): str
+ get_username(): str
+ get_url(): str
+ show(): void
+ hide(): void
+ download_icon(): void
+ build(): void
}

class InfoCard {
- homepage: Homepage
- title: str
- passID: int
+ __init__(homepage: Homepage, title: str, passID: int): void
+ get_title(): str
+ show(): void
+ hide(): void
+ build(): void
}


class Viewer {
# type: str
# homepage: Homepage
# passID: int
# current_password: str
# current_manager: int
# current_password_viewing: TextButton
# visibility_icon: IconButton
# manager_checkbox: Checkbox
# help_button: IconButton
+ __init__(homepage: Homepage, passID: int, password: str, manager: int, type: str): void
# unhide_password_viewing(e): void
# return_to_on(e): void
+ build_full(col, img): void
}

class PasswordViewer {
- current_title: str
- current_username: str
- url: str
- current_additional_info: str
+ __init__(homepage: Homepage, passID: int, title: str, password: str, username: str, url: str, manager: int, additional_info: str): void
+ build(): void
}

class InfoViewer {
- current_title: str
+ __init__(homepage: Homepage, title: str, passID: int, password: str, manager: int): void
+ build(): void
}

class NewPassword {
- passID: int
- title: str
- sender_email: str
- sender_name: str
- sender_surname: str
- homepage: Homepage
+ __init__(passID: int, title: str, sender_email: str, sender_name: str, sender_surname: str, homepage: Homepage): void
+ attempt_confirm(): void
- delete(e): void
+ check_box_true(): void
+ build(): void
}

class ReceiveShared {
- homepage: Homepage
- data: Data
- processing: bool
- receiving_password_list: list
+ __init__(homepage: Homepage, data: Data): void
- select_all(e): void
- upload(e): void
- back(e): void
+ build(): void
}

class PasswordRow {
- username: str
- title: str
- rating: float
- repeated: bool
- passID: int
- function: function
- type: str
- url: str
- slider: Slider
- repeated_alert: Text
- img: Image or Icon
- container: Container
+ __init__(username: str, title: str, rating: float, repeated: bool, passID: int, url: str, function: function): void
+ get_type(): str
- go_to_password(e): void
- reset_slider(e): void
+ build(): Container
}

class Scanner {
- homepage: Homepage
- data: Data
- password_row_list: list
+ __init__(homepage: Homepage, data: Data): void
- view_password(passID, type): void
- back(e): void
+ build(): Column
}

class Settings {
- homepage: Homepage
- data: Data
- processing: bool
+ __init__(homepage: Homepage, data: Data)
- back(e): void
- change_theme(e): void
- remove_lockdown(e): void
- change_password(e): void
+ build(): Stack
}

class Sharer {
- homepage: Homepage
- data: Data
- page: Page
- passID: str
- type: str
- processing: bool
- recipient_userID: str
- recipient_forename: str
- recipient_name: str
- recipient_email: str
+ __init__(homepage: Homepage, data: Data, passID: int, type: str)
- reset_user_boxes(e): void
- show_user_to_share(e): void
- confirm_access_rights(e): void
- confirm_to_send(e): void
- final_send_password(e): void
- back(e): void
+ build(): Stack
}

class Updater {
- homepage: Homepage
- passID: int
- type: str
- processing: bool
- password: str
- title: str
- username: str
- url: str
- additional_info: str
- username_input_field: TextField
- url_input_field: TextField
- additional_info_input_field: TextField
- title_input_field: TextField
- password_input_field: TextField
- back_button: IconButton
- update_button: ElevatedButton
- col: Column
+ __init__(homepage: Homepage, passID: int, type: str): void
- update(e): void
- back(e): void
+ build(): Column
}


class ViewUsers {
- homepage: Homepage
- data: Data
- passID: int
- type: str
- processing: bool
- back_button: IconButton
- managers_container: Container
- users_container: Container
- new_manager_text_field: Input
- remove_user_text_field: Input
- img: Icon
- col: Column
+ __init__(homepage: Homepage, data: Data, passID: int, type: str): void
- back(e): void
- add_manager(e): void
- remove_user(e): void
+ build(): Stack
}

class Login {
- page: Page
- data: Data
- processing: bool
- email_input: Input
- password_input: Input
- stay_signed_in: Checkbox
- sign_in_button: ElevatedButton
- login_success: Text
- container_info: Container
- stack: Stack
- card: Card
+ __init__(page: Page, data: Data): void
+ attempt_auto_login(): void
- add_account(e): void
- add_device(e): void
- attempt_login(e): void
+ build(): Card
}

class Navbar {
- page: Page
+ __init__(page: Page)
- close(e)
- minimise(e)
+ build(): Card
}

class Newaccount {
- page: Page
- data: Data
- processing: bool
+ __init__(page: Page, data: Data): void
- try_again(): void
- confirm_password(e): void
- attempt_add_account(e): void
+ build(): Card
}

class Newdevice {
- page: Page
- data: Data
- processing: bool
+ __init__(page: Page, data: Data): void
- close_dlg(e): void
- return_to_login(e): void
- attempt_add_device(e): void
+ build(): Card
}

class Receivecode {
- page: Page
- data: Data
- processing: bool
- email: str
- function: function
+ __init__(page: Page, data: Data, email: str, type: str): void
- check_data(e): void
- attempt_verify_account(e): void
- attempt_add_device(e): void
- return_to_login(e): void
+ build(): Card
}